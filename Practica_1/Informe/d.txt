\section{Resultados}

Se ejecutó los bloques de la Fig.2 con una señal cuadrada de amplitud 1, offset -0.5 y frecuencia 2 [kHz], obteniendo como resultado para el acumulador una señal triangular de la misma frecuencia, es decir, 2 [kHz] y una amplitud diferente,  lo cual corresponde con el comportamiento teórico donde la integral de una señal cuadrada periódica resulta en una señal triangular. Mientras que en el diferenciador se observa la variación de la señal entre 2 valores que van creciendo en el transcurso del tiempo y corresponde a la razón, se cambió de la señal cuadrada.\\

\noindent
 Mientras en el caso de la señal vectorial se utilizó el vector=[-1,0,1] con el fin de visualizar un correcto funcionamiento de los bloques, en el caso del acumulador varía entre los valores y al sumarse se anulan  obteniendo cero, repitiendo este procedimiento la cantidad de veces que se repita el vector. Mientras que en el caso del diferenciador observamos que va variando su signo y aumentando su magnitud en el transcurso del tiempo, tal como se visualiza en la Fig. \ref{fig:punto2_a}.3
 \smallskip\\

 {\centering
    \includegraphics[scale=0.20]{figs/Resultados_Acu_Diff.png}\\
    Fig.3.3 Resultados obtenidos del bloque acumulador y diferenciador tanto para una señal periódica cuadrada y un vector repetitivo. 
    \label{fig:punto2_a}
    }\smallskip\\
    \noindent
    Mientras que en el caso del bloque estadístico y su aplicación (Ver Fig.\ref{fig:punto1_b}.2), se realizó la evaluación de los bloques, variando el ruido Gaussiano desde 0 hasta 0.1, y registrando sus valores para su posterior comparación. \\
    \smallskip\\
    Calculado sus valores teóricos obtenemos:

\begin{equation}
    \text{Media}=\frac{1}{\frac{1}{2000}}\int_{0}^{\frac{1}{2000}} sin( 4000 \pi x) \,dx = 0
\end{equation}

\begin{equation}
    \text{M. C.}=\frac{1}{\frac{1}{2000}}\int_{0}^{\frac{1}{2000}} sin( 4000 \pi x)^2 \,dx = \frac{1}{2}
\end{equation}

\begin{equation}
    \text{RMS}=\sqrt{\frac{1}{\frac{1}{2000}}\int_{0}^{\frac{1}{2000}} sin( 4000 \pi x)^2 \,dx} = \frac{1}{\sqrt{2}}
\end{equation}

\begin{equation}
    \text{Potencia}=\frac{1}{\frac{1}{2000}}\int_{0}^{\frac{1}{2000}} sin( 4000 \pi x)^2 \,dx= \frac{1}{2}
\end{equation}

\begin{equation}
    \text{D.E.}=\sqrt{\frac{1}{\frac{1}{2000}}\int_{0}^{\frac{1}{2000}} \left(sin( 4000 \pi x) - 0 \right)^2\,dx}= \frac{1}{\sqrt{2}}   
\end{equation}\\
\noindent
Como se observa en la Tabla \ref{tab:my_label}.1 los valores más cercanos a los teóricos obtenidos en las ecuaciones (1,2,3,4,5) se obtienen a través de la implementación de la aplicación (2) cuando el ruido es cero, siendo estos iguales, aunque se destaca que con los bloques de estadística (1) varía levemente solo en el 4 o 3 decimal, si aumentamos el ruido se mantiene ese patrón con excepción de la media.
\\

      { \scriptsize
      \centering
        \begin{tabular}{|c|c|c|c|c|c|} 
             \hline
            Ruido & Media & Media & RMS &Potencia& Desviación \\ 
             &  &cuadrada& & promedio  &estandar \\ \hline
           0 (1)  & 0  &  0.5002 & 0.7073 &0.5002 &0.7073 \\ \hline
           0 (2)   & 0 & 0.5000 &  0.7071& 0.5000& 0.7071\\ \hline
           0.25 (1)  & 0  & 0.5003& 0.7073 &0.5003 &0.7073 \\ \hline
           0.25 (2)   & 0 & 0.5001&  0.7071& 0.5002& 0.7072\\ \hline
           0.05 (1)  &0.0001  & 0.5028 &  0.7091& 0.5028 & 0.7088\\ \hline
           0.05 (2) &0  & 0.5008 &  0.7077& 0.5008 &0.7077 \\ \hline
           0.1 (1)  & 0 &0.5113 & 0.7152 & 0.5112 &0.7141 \\ \hline
           0.1 (2) &  0.0002& 0.5100 & 0.7138& 0.5100 & 0.7137\\ \hline
        \end{tabular}
        \\Tabla 3.1. Resultados de los bloques de estadística(1) y aplicación(2) para diferentes niveles de ruido en una señal seno.
        \label{tab:my_label}
}
    \\
    Todos los bloques y códigos se encuentran en el repositorio de GitHub \url{https://github.com/ValeriaS57/CommunicationsII_2024_2_B1_ONV/tree/834a6792b8bf02a7dda7d7d4ef9ec1b615370e61/Practica_1}


\section{Conclusiones}
\\
Referente al desarrollo de los códigos propuestos se le hicieron pequeñas modificaciones como arreglar la indentación, cambiar unas comillas y corregir el orden de unas líneas de código para su correcto funcionamiento. En el caso del bloque acumulador y diferenciador si tenemos una señal que su media no es cero, y sus valores están sobre el eje positivo los valores de salida de los bloques tienden a infinito, pero en la realidad de la implementación llegan a un punto donde se desbordan y  reinicia la operación como ocurría en sistemas digitales.\\\\
\noindent
Comparando la programación del bloque estadístico que utilizó los códigos propuestos en el libro guía y el código de la aplicación modificado con funciones propias de Python obtenidas de la librería NumPy, tal como np.mean(), así como el uso de ventanas de tamaño $2^{12}$ muestras para mejorar los valores, se observa que presenta una gran exactitud cuando su ruido es cero, pero mientras más crece sus valores varían un poco entre ellos y tarda más para estabilizarse en comparación al código propuesto.\\\\
\noindent
